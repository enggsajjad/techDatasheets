//=============================================================================
// Copyright (C) 2003 Atmel Corporation
//
// File:			OutputWriter.cpp
// Compiler:		Microsoft Visual C++ 6.0
// Output Size:
// Created:			4-Feb-2003	JP (Atmel Finland)
// Modified:
//
// Support Mail:	avr@atmel.com
//
// Description:		OutputWriter is able to generate three files:
//						- A header file for 'bootldr' which configurates the
//						  bootloader
//						- A key file for 'bootldr' to decrypt the received
//						  data properly
//						- DES encrypted file that can be sent to the target
//						  AVR in public
//
// Other Info:		
//=============================================================================


#include "OutputWriter.h"
#include "MemoryMap.h"
#include "DES.h"
#include "CreateException.h"
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <string.h>


const int signatureSize = 4;
const int recordHeaderSize = 6;
const int cipherBlockSize = 8;
const int endOfFrameRecordSize = 1;


//=============================================================================
// Constructor

OutputWriter::OutputWriter(MemoryMap *flash, MemoryMap *eeprom,
	unsigned int pageSize, DataBuffer *key, DataBuffer& initialVector,
	DataBuffer& signature, bool updateLockBits, unsigned char lockBits,
	unsigned int memSize, int keyCount, bool createFlashCRC, bool eraseFlash,
	bool nonsenseRecords
	) :
	pageSizeM(pageSize),
	memSizeM(memSize), 

	// Maximum frame size can be calculated from the AVR page size
	frameMaxSizeM(
		((signatureSize + recordHeaderSize + pageSize + endOfFrameRecordSize)
			+ (cipherBlockSize - 1)
		) / cipherBlockSize * cipherBlockSize),

	// Maximum size of one record (maximum payload of one frame)
	recordMaxSizeM(frameMaxSizeM - signatureSize - endOfFrameRecordSize),

	// Number of bytes that must to be allocated from the SRAM of the target
	// AVR for reception buffer.
	bufferSizeM(2 + frameMaxSizeM + 2),

	signatureM(DataBuffer(signature)),
	initialVectorM(DataBuffer(initialVector)),

	desM(new Des(initialVector)),
	flashM(flash),
	eepromM(eeprom),

	keyCountM(keyCount),
	keyM(key),

	updateLockBitsM(updateLockBits),
	lockBitsM(lockBits),

	frameBufferM(DataBuffer()),

	createFlashCRCM(createFlashCRC),
	eraseFlashM(eraseFlash),
	nonsenseProbabilityM(nonsenseRecords ? 1 : 0)

{
	desM->scheduleKey(key);

	if (createFlashCRCM && flashM)
	{
		// Calculates the CRC of Application Section and inserts it to the
		// MemoryMap of the flash memory
		unsigned int address;
		unsigned short crcCode = 0;
		DataBuffer crcBuffer;

		for (address = 0; address < memSizeM - 2; address++)
			crcCode = crc(flashM->at(address), crcCode);

		crcCode = crc(0, crcCode);
		crcCode = crc(0, crcCode);

		crcBuffer += (unsigned char)(crcCode >> 8);
		crcBuffer += (unsigned char)(crcCode & 0xff);

		flashM->insert(memSizeM - 2, crcBuffer);
	}
}


//=============================================================================
// Destructor

OutputWriter::~OutputWriter()
{
	delete desM;
}


//=============================================================================
// Write a DES key file for 'bootldr'.

// The following does not necessarily print well (line wraps)!
const char keyFileComment[] =
{
"//==============================================================================\n"
"// File:           %s\n"
"// Compiler:       IAR Atmel AVR C/EC++ Compiler\n"
"// Output Size:    %d\n"
"// Created:        %s\n"
"//\n"
"// Description:    This file is generated by 'create' tool and is to be included\n"
"//                 in the 'bootldr' project. It contains a DES key table for\n"
"//                 a proper decryption of the file encrypted using the same\n"
"//                 configurations.\n"
"//\n"
"// Keys used:      KEY1 = %s\n"
"//                 KEY2 = %s\n"
"//                 KEY3 = %s\n"
"//==============================================================================\n"
"\n"
"\n"
};


void OutputWriter::writeKeyFile(char *filename)
{
	FILE *keyFile;
	int lines = (keyCountM * 16) - 1;
	int i;

	if (keyFile = fopen(filename, "w"))
	{
		char dateString[32];
		_strdate(dateString);

		// Remove path from the filename
		char filenameStripped[64], filenameExtension[32];
		_splitpath(filename, NULL, NULL, filenameStripped, filenameExtension);
		strcat(filenameStripped, filenameExtension);

		// Print comment area
		fprintf(keyFile, keyFileComment, filenameStripped, keyCountM * 16 * 6,
			dateString, keyM[0].toHexString(),
			((keyCountM > 1) ? keyM[1].toHexString() : "N/A"),
			((keyCountM > 2) ? keyM[2].toHexString() : "N/A")
		);

		fprintf(keyFile, "%s unsigned char kTable[%d * 6] = \n{\n",
			((memSizeM > 65536) ? "__farflash" : "__flash"), keyCountM * 16);

		// Print key 1 data
		if (keyCountM > 0)
			for (i = 0; i < 16; i++, lines--)
				fprintf(keyFile, lines ? "\t%s,\n" : "\t%s\n",
					desM->getK(2, 15 - i).toCHexString());

		// Print key 2 data
		if (keyCountM > 1)
		{
			fprintf(keyFile, "\n");
			
			for (i = 0; i < 16; i++, lines--)
				fprintf(keyFile, lines ? "\t%s,\n" : "\t%s\n",
					desM->getK(1, i).toCHexString());
		}

		// Print key 3 data
		if (keyCountM > 2)
		{
			fprintf(keyFile, "\n");

			for (i = 0; i < 16; i++, lines--)
				fprintf(keyFile, lines ? "\t%s,\n" : "\t%s\n",
					desM->getK(0, 15 - i).toCHexString());
		}

		fprintf(keyFile, "};\n");

		fclose(keyFile);
	}
	else
		throw new CreateException(ERROR_CREATE_FILE, filename);
}


//=============================================================================
// Writes a header file for 'bootldr' containing all information necessary to
// customize the boot loader for a specific AVR and DES keys.

const char headerFileComment[] =
{
"//==============================================================================\n"
"// File:           %s\n"
"// Compiler:       IAR Atmel AVR C/EC++ Compiler\n"
"// Output Size:    -\n"
"// Created:        %s\n"
"//\n"
"// Description:    This file is generated by 'create' tool and is to be included\n"
"//                 in the 'bootldr' project. It contains the settings to\n"
"//                 configure the boot loader according to the configurations\n"
"//                 used in the encrypted file.\n"
"//==============================================================================\n"
"\n"
"\n"
};

void OutputWriter::writeHeaderFile(char *filename)
{
	FILE *headerFile;

	if (headerFile = fopen(filename, "w"))
	{
		char dateString[32];
		_strdate(dateString);

		// Remove path from the filename
		char filenameStripped[64], filenameExtension[32];
		_splitpath(filename, NULL, NULL, filenameStripped, filenameExtension);
		strcat(filenameStripped, filenameExtension);

		// Write the comment in the beginning of the file
		fprintf(headerFile, headerFileComment, filenameStripped, dateString);

		// Convert 'filename.ext' to 'FILENAME_EXT'
		_strupr(filenameStripped);
		char *dotIndex = strchr(filenameStripped, '.');
		*dotIndex = '_';

		fprintf(headerFile, "#ifndef %s\n", filenameStripped);
		fprintf(headerFile, "#define %s\n\n\n", filenameStripped);

		// Write #define's
		fprintf(headerFile, "#define PAGE_SIZE %d\n", pageSizeM);
		fprintf(headerFile, "#define MEM_SIZE %d\n", memSizeM);
		
		if (createFlashCRCM)
			fprintf(headerFile, "#define CRC_CHECK\n");

		fprintf(headerFile, "#define SIGNATURE 0x%s\n",
			signatureM.toHexString());

		fprintf(headerFile, "#define BUFFER_SIZE %d\n", bufferSizeM);

		fprintf(headerFile, "#define INITIALVECTOR_HI 0x%s\n",
			initialVectorM.toHexString(0, 4));

		fprintf(headerFile, "#define INITIALVECTOR_LO 0x%s\n",
			initialVectorM.toHexString(4, 4));

		fprintf(headerFile, "#define KEY_COUNT %d\n", keyCountM);

		fprintf(headerFile, "\n\n#endif // %s\n", filenameStripped);

		fclose(headerFile);
	}
}


//=============================================================================
// Prepares and writes one frame.

void OutputWriter::writeFrame()
{
	// If no data to write -> do not write.
	if (frameBufferM.size() == 0)
		return;

	// Insert signature in front of the frame
	frameBufferM.insert(0, signatureM);

	// Insert 'End Of Frame' frame
	frameBufferM += (unsigned char)0x00;

	if (keyCountM > 0)
		desM->encryptBuffer(frameBufferM);

	// Calculate CRC
	unsigned int crcCode = 0;

	for (unsigned char *i = frameBufferM.begin(); i != frameBufferM.end(); i++)
		crcCode = crc(*i, crcCode);
	
	crcCode = crc(0, crcCode);
	crcCode = crc(0, crcCode);

	// Append CRC
	frameBufferM += (unsigned char)(crcCode >> 8);
	frameBufferM += (unsigned char)(crcCode & 0xff);

	// Write first the frame size and then the frame (including CRC)
	fprintf(outputFileM, "%04X", frameBufferM.size());
	fprintf(outputFileM, "%s", frameBufferM.toHexString());

	// Erase frame buffer for the next frame
	frameBufferM.erase();
}


//=============================================================================
// Inserts a record into frame. If the frame is already too full, writes the
// old frame and start a new one.

void OutputWriter::insertRecord(DataBuffer& record)
{
	// Shall we create some nonsense records before the real record?
	if ((float)rand()/RAND_MAX < nonsenseProbabilityM)
	{
		// Use exponential distribution function for the number of
		// nonsense records (i.e. favor smaller number of nonsense records)
		for (
			float probability = 1.0;
			(float)rand()/RAND_MAX < probability;
			probability = 0.93 * probability)
		{
			// If there is no room for nonsense records, write the frame
			if (frameBufferM.size() == recordMaxSizeM)
				writeFrame();

			// Add one byte of nonsense
			frameBufferM += 
				(unsigned char)(
					rand() % (TYPE_NONSENSE_LAST - TYPE_NONSENSE_FIRST + 1) +
						TYPE_NONSENSE_FIRST
				);
		}
	}

	// Use exponential distribution function of probability for the decision
	// of creating nonsense records i.e. lower the chances of nonsense records
	// after each real record, so there is a bigger probability of creating
	// nonsense records in the beginning of the output file (which can be
	// guessed more easily than the rest of the file).
	nonsenseProbabilityM = nonsenseProbabilityM * 0.9;

	if (frameBufferM.size() + record.size() > recordMaxSizeM)
		writeFrame();

	frameBufferM.append(record);

	delete &record;
}


//=============================================================================
// Writes Application Section update data.

void OutputWriter::writeFlash()
{
	// Page address
	unsigned int pageAddress;

	// Start address of the first page containing data
	unsigned int lowPage = flashM->getLowestAddress() / pageSizeM * pageSizeM;

	// Start address of the page after the last page containing data
	unsigned int highPage =
		flashM->getHighestAddress() / pageSizeM * pageSizeM + pageSizeM - 1;
	
	for (pageAddress = lowPage; pageAddress <= highPage;
		pageAddress += pageSizeM)
	{
		bool dataOnPage = false;	// Data found from the current page?

		unsigned int index = 0;		// Index counter on this page

		while (index < pageSizeM)
		{
			if (flashM->in(pageAddress + index))
			{
				// Find the number of successive data bytes on this page, ...
				unsigned int lastindex = index;

				while ((lastindex < pageSizeM) &&
					flashM->in(pageAddress + lastindex)
				)
					lastindex++;

				unsigned int count = lastindex - index;

				// First data chunk found on this page?
				//   Yes ->
				//		The chunk fills the whole page?
				//			-> no need for preparing
				//		Flash erase requested?
				//			-> insert CSEG_ERASE record
				//		Otherwise:
				//			-> insert CSEG_PREPARE record
				if (!dataOnPage)
				{
					if (count < pageSizeM)
					{
						if (eraseFlashM)
							insertRecord(buildRecordErase(pageAddress));
						else
							insertRecord(buildRecordPrepare(pageAddress));
					}

					dataOnPage = true;
				}

				// ... wrap it inside a record and insert in the frame
				insertRecord(buildRecordWrite(pageAddress, index, count));

				// Update index
				index = lastindex;
			}
			else
				index++;
		}

		if (dataOnPage)
			// If there was data on the page, insert PROGRAM record
			insertRecord(buildRecordProgram(pageAddress));
		else if (eraseFlashM)
			// There was no data on the page, but all pages are forced to get
			// erased (by sending an ERASE record)
			insertRecord(buildRecordErase(pageAddress));
	}
}


//=============================================================================
// Writes EEPROM update data.

void OutputWriter::writeEEPROM()
{
	// Scan through the whole eeprom memory map for data
	unsigned int address = eepromM->getLowestAddress();
	
	while (address <= eepromM->getHighestAddress())
	{
		// Data in eeprom at 'address'?
		if (eepromM->in(address))
		{
			// Find the number of successive data bytes, ...
			int lastAddress = address;

			// (also check that the number of successive bytes is less than
			// what fits into one frame, which is the flash page size)
			while (eepromM->in(lastAddress) &&
				((lastAddress - address) < pageSizeM))
				lastAddress++;

			// ... wrap it inside a record and insert in the frame
			insertRecord(buildRecordEEPROM(address, lastAddress - address));

			address = lastAddress;
		}
		else
			address++;
	}
}


//=============================================================================
// Writes lock bits record.

void OutputWriter::writeLockBits()
{
	insertRecord(buildRecordLockBitsWrite());
}


//=============================================================================
// Writes 'Reset software' record.

void OutputWriter::writeResetSW()
{
	insertRecord(buildRecordResetSW());
}


//=============================================================================
// Creates a new encrypted file named 'filename', inserts all data to be
// updated in the target AVR into file, and encrypts it using DES/3DES
// encryption algorithm.

void OutputWriter::writeOutputFile(char *filename)
{
	if (outputFileM = fopen(filename, "w"))
	{
		// Write flash contents
		if (flashM)
			writeFlash();

		// Write EEPROM contents
		if (eepromM)
			writeEEPROM();

		// Write Lock Bits
		if (updateLockBitsM)
			writeLockBits();

		// End the programming by resetting the AVR
		writeResetSW();
		
		// Flush the frame buffer
		writeFrame();

		fclose(outputFileM);
	}
	else 
		throw new CreateException(ERROR_CREATE_FILE, filename);
}


//=============================================================================
// Update a CRC counter ('oldCRC') with 'ch'.

unsigned short OutputWriter::crc(unsigned char ch, unsigned short oldCRC)
{
	static const unsigned short crcPoly = 0x8005;
	
	int n;
	unsigned long m;

	m = ((unsigned long)oldCRC << 8) | ch;
	for (n = 0; n < 8; n++)
		if ((m <<= 1) & 0x1000000)
			m ^= ((unsigned int)crcPoly << 8);

	return (unsigned short)(m >> 8);
}


//=============================================================================
// Build a record.

DataBuffer& OutputWriter::buildRecord(RecordType type, int address, int size,
									  const DataBuffer& buffer)
{
	DataBuffer& record = *new DataBuffer(6 + buffer.size());

	record[0] = type;
	record[1] = address >> 16;
	record[2] = address >> 8;
	record[3] = address;
	record[4] = size >> 8;
	record[5] = size;

	for (int i = 0; i < buffer.size(); i++)
		record[i + 6] = buffer[i];

	return record;
}


//=============================================================================
// Build a record for erasing and preparing an Application Section page for the
// following data chunk writes.

DataBuffer& OutputWriter::buildRecordErase(unsigned int pageAddress)
{
	return buildRecord(TYPE_ERASE, pageAddress, pageSizeM, DataBuffer());
}


//=============================================================================
// Build a record for preparing an Application Section page for the following
// data chunk writes.

DataBuffer& OutputWriter::buildRecordPrepare(unsigned int pageAddress)
{
	return buildRecord(TYPE_PREPARE, pageAddress, pageSizeM, DataBuffer());
}


//=============================================================================
// Build a record for writing a chunk of Application Section data.

DataBuffer& OutputWriter::buildRecordWrite(unsigned int pageAddress,
										   unsigned int index, size_t length)
{
	DataBuffer buffer(length);

	for (int i = 0; i < length; i++)
		buffer[i] = flashM->at(pageAddress + index + i);

	return buildRecord(TYPE_DATA, index, length, buffer);
}


//=============================================================================
// Build a record for programming a page to flash memory.

DataBuffer& OutputWriter::buildRecordProgram(unsigned int pageAddress)
{
	return buildRecord(TYPE_PROGRAM, pageAddress, pageSizeM / 2, DataBuffer());
}


//=============================================================================
// Build a record for writing a chunk of EEPROM data.

DataBuffer& OutputWriter::buildRecordEEPROM(unsigned int address,
											size_t length)
{
	DataBuffer buffer(length);

	for (int i = 0; i < length; i++)
		buffer[i] = eepromM->at(address + i);

	return buildRecord(TYPE_EEPROM, address, length, buffer);
}


//=============================================================================
// Build a record for writing lock bits.

DataBuffer& OutputWriter::buildRecordLockBitsWrite()
{
	return buildRecord(TYPE_LOCKBITS, (int)lockBitsM << 16, rand(),
		DataBuffer());
}


//=============================================================================
// Build a record for reseting the SW (the last record to be sent).

DataBuffer& OutputWriter::buildRecordResetSW()
{
	return buildRecord(TYPE_RESET, rand(), rand(), DataBuffer());
}
